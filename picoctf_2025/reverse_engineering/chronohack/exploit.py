from pwn import *
import time
import random
import threading
from concurrent.futures import ThreadPoolExecutor
import queue
import logging
import os

# ログ設定
log_dir = "logs"
os.makedirs(log_dir, exist_ok=True)
log_file = os.path.join(log_dir, f"token_attack_{int(time.time())}.log")

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(threadName)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(log_file),
        logging.StreamHandler(),
    ],
)

logger = logging.getLogger("token_attack")


def get_random(length, seed):
    alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
    random.seed(seed)
    s = ""
    for i in range(length):
        s += random.choice(alphabet)
    return s


found_event = threading.Event()  # フラグ発見イベント


def worker(seed_queue: queue.Queue, host, port, lock):
    try:
        with lock:  # remoteオブジェクトの作成をロック
            p = remote(host, port)
            p.recvuntil(b"Enter your guess for the token (or exit):")

        while not found_event.is_set():
            try:
                seed = seed_queue.get_nowait()
            except queue.Empty:
                break

            token = get_random(20, seed)

            with lock:  # 送受信をロック
                p.sendline(token.encode())
                try:
                    response = p.recvline(timeout=2).decode().strip()
                except Exception as e:
                    logger.error(f"Error receiving data: {e}")
                    break

            logger.debug(f"Trying seed {seed}: {token}")  # デバッグレベル

            if "Congratulations!" in response:
                with lock:  # フラグ受信をロック
                    flag_data = ""
                    try:
                        while True:
                            line = p.recvline(timeout=2).decode().strip()
                            flag_data += line + "\n"
                            if "picoCTF{" in line:
                                break
                    except Exception as e:
                        logger.error(f"Error receiving flag: {e}")

                    with open("flag.txt", "w") as f:
                        f.write(f"Seed: {seed}\n")
                        f.write(f"Token: {token}\n")
                        f.write(flag_data)

                    print("\n" + "=" * 30)
                    print("      FLAG FOUND!!! (See flag.txt)")
                    print("=" * 30)
                    print(f"   Seed: {seed}")
                    print(f"   Token: {token}")
                    print("-" * 30)
                    print(f"   {flag_data.strip()}")
                    print("=" * 30 + "\n")

                found_event.set()
                break

    except Exception as e:
        logger.exception(f"Connection error: {e}")
    finally:
        try:
            with lock:
                p.close()
        except:
            pass


def estimate_time_offset(host, port, num_samples=10):
    """サーバーとの時間オフセットをより正確に推定"""
    offsets = []
    for _ in range(num_samples):
        try:
            p = remote(host, port)
            client_send_time = time.time()
            p.recvuntil(b"Can you guess the token?")
            client_recv_time = time.time()
            server_time_hint = (client_send_time + client_recv_time) / 2
            p.close()
            offset = server_time_hint - client_send_time  # オフセット
            offsets.append(offset)
            time.sleep(0.05)  # 短いdelay
        except Exception as e:
            logger.error(f"Time offset estimation error: {e}")
            return None  # エラー時はNoneを返す

    # オフセットの平均を返す
    return sum(offsets) / len(offsets) if offsets else None


def main():
    host = "verbal-sleep.picoctf.net"
    port = 50772

    time_offset = estimate_time_offset(host, port)
    if time_offset is None:
        logger.error("Failed to estimate time offset. Exiting.")
        return

    logger.info(f"Estimated time offset: {time_offset:.6f} seconds")

    # オフセット考慮した現在時刻から探索開始
    estimated_server_time = time.time() + time_offset
    start_time_ms = int(estimated_server_time * 1000)

    # 探索範囲 (ミリ秒単位)
    time_range_ms = 2000  # ±2秒

    # シード値キューを作成
    seed_queue = queue.Queue()
    for i in range(start_time_ms - time_range_ms, start_time_ms + time_range_ms + 1):
        seed_queue.put(i)

    max_workers = 64  # スレッド数
    lock = threading.Lock()  # ロック

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        for _ in range(max_workers):
            executor.submit(worker, seed_queue, host, port, lock)

    if not found_event.is_set():
        logger.info("Flag not found.")


if __name__ == "__main__":
    main()
